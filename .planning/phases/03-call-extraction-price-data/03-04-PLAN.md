---
phase: 03-call-extraction-price-data
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - api/app/controllers/api/v1/calls_controller.rb
  - api/app/controllers/api/v1/assets_controller.rb
  - api/app/controllers/api/v1/price_snapshots_controller.rb
  - api/config/routes.rb
autonomous: true

must_haves:
  truths:
    - "API returns calls for a given influencer with asset and direction data"
    - "API returns calls for a given asset with influencer data"
    - "API returns price snapshots for a given asset within a date range"
    - "API returns list of assets that have calls associated"
    - "All endpoints return paginated JSON with meta information"
  artifacts:
    - path: "api/app/controllers/api/v1/calls_controller.rb"
      provides: "Calls listing endpoint with influencer and asset filtering"
      contains: "def index"
    - path: "api/app/controllers/api/v1/assets_controller.rb"
      provides: "Assets listing endpoint"
      contains: "def index"
    - path: "api/app/controllers/api/v1/price_snapshots_controller.rb"
      provides: "Price data endpoint for chart rendering"
      contains: "def index"
  key_links:
    - from: "api/config/routes.rb"
      to: "api/app/controllers/api/v1/calls_controller.rb"
      via: "routes definition"
      pattern: "resources :calls"
    - from: "api/app/controllers/api/v1/calls_controller.rb"
      to: "api/app/models/call.rb"
      via: "ActiveRecord queries"
      pattern: "Call\\."
    - from: "api/app/controllers/api/v1/price_snapshots_controller.rb"
      to: "api/app/models/price_snapshot.rb"
      via: "ActiveRecord queries"
      pattern: "PriceSnapshot"
---

<objective>
Create API endpoints for calls, assets, and price snapshots so the Phase 4 frontend can display call data on charts.

Purpose: The frontend needs to fetch calls (per influencer or per asset), list available assets, and get price time series data. These endpoints complete the Phase 3 data pipeline by making it accessible.
Output: Three new API controllers with routes for calls, assets, and price snapshots.
</objective>

<execution_context>
@/Users/superuser/.claude/get-shit-done/workflows/execute-plan.md
@/Users/superuser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@api/app/models/call.rb
@api/app/models/asset.rb
@api/app/models/price_snapshot.rb
@api/config/routes.rb
@api/app/controllers/api/v1/contents_controller.rb
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create calls and assets API controllers</name>
  <files>
    api/app/controllers/api/v1/calls_controller.rb
    api/app/controllers/api/v1/assets_controller.rb
    api/config/routes.rb
  </files>
  <action>
    1. Create `api/app/controllers/api/v1/calls_controller.rb`:
       - Class Api::V1::CallsController < ApplicationController
       - Follow the same patterns as the existing ContentsController (manual pagination with meta object, JSON serialization in controller)
       - `index` action:
         - Accept query params: influencer_id, asset_id, direction, min_confidence, page, per_page
         - Base scope: `Call.includes(:asset, :influencer, :content).high_confidence.recent`
         - Filter by influencer_id if provided
         - Filter by asset_id if provided
         - Filter by direction if provided ("bullish" or "bearish")
         - Filter by min_confidence if provided (default: 0.7)
         - Paginate: page (default 1), per_page (default 25, max 100)
         - Return JSON with calls array and meta (page, per_page, total, total_pages)
         - Each call serialized as: { id, direction, confidence, quote, reasoning, called_at, asset: { id, symbol, name, asset_class }, influencer: { id, name, avatar_url }, content: { id, type, title, external_id } }

    2. Create `api/app/controllers/api/v1/assets_controller.rb`:
       - Class Api::V1::AssetsController < ApplicationController
       - `index` action:
         - Accept query param: with_calls (boolean, default false)
         - If with_calls=true: `Asset.joins(:calls).distinct.order(:symbol)` -- only assets that have been called
         - Else: `Asset.order(:symbol)` -- all seeded assets
         - Accept query param: asset_class ("crypto" or "macro") for filtering
         - Return JSON array of assets: { id, symbol, name, asset_class, coingecko_id, yahoo_ticker }
         - No pagination needed (fixed small set of ~15 assets)
       - `show` action:
         - Find asset by ID
         - Return asset JSON with additional stats: { ...asset, calls_count: asset.calls.count, latest_call_at: asset.calls.maximum(:called_at) }

    3. Update `api/config/routes.rb`:
       - Inside the existing `namespace :api` / `namespace :v1` block, add:
         - `resources :calls, only: [:index]`
         - `resources :assets, only: [:index, :show]`
         - Also add calls nested under influencers: `resources :calls, only: [:index]` inside the existing `resources :influencers` block (alongside :youtube_channels, :twitter_accounts, :contents)
       - This gives both `/api/v1/calls?influencer_id=X` (flat) and `/api/v1/influencers/:influencer_id/calls` (nested) access patterns
       - For nested calls, scope to the influencer automatically via set_influencer before_action
  </action>
  <verify>
    Run `ruby -c api/app/controllers/api/v1/calls_controller.rb` -- syntax OK.
    Run `ruby -c api/app/controllers/api/v1/assets_controller.rb` -- syntax OK.
    Run `bin/rails routes | grep -E "calls|assets"` -- should show call and asset routes.
    Run `bin/rails runner "puts Api::V1::CallsController.new.respond_to?(:index)"` -- should print true.
  </verify>
  <done>CallsController with filtered/paginated listing (by influencer, asset, direction, confidence). AssetsController with index (optionally filtered to assets with calls) and show (with call stats). Routes added for both flat and nested access patterns.</done>
</task>

<task type="auto">
  <name>Task 2: Create price snapshots API controller</name>
  <files>
    api/app/controllers/api/v1/price_snapshots_controller.rb
    api/config/routes.rb
  </files>
  <action>
    1. Create `api/app/controllers/api/v1/price_snapshots_controller.rb`:
       - Class Api::V1::PriceSnapshotsController < ApplicationController
       - `index` action:
         - REQUIRED param: asset_id (return 400 if missing)
         - Optional params: start_date, end_date, interval
         - Find asset by asset_id (return 404 if not found)
         - Default date range: 1 year ago to today
         - Parse start_date and end_date as dates if provided
         - Query: `asset.price_snapshots.for_range(start_time, end_time).chronological`
         - Return JSON: { asset: { id, symbol, name }, price_data: [{ timestamp, open, high, low, close, volume }, ...], meta: { count, start_date, end_date } }
         - No pagination -- return all data points in range (typically 365 daily candles max, well within JSON response limits)
         - Timestamps should be ISO 8601 format

    2. Update `api/config/routes.rb`:
       - Add inside the api/v1 namespace:
         - `resources :price_snapshots, only: [:index]`
       - Also nest under assets for RESTful access: inside a new `resources :assets` block, add `resources :price_snapshots, only: [:index]`
       - This gives `/api/v1/price_snapshots?asset_id=X` and `/api/v1/assets/:asset_id/price_snapshots`
       - Make sure not to duplicate the assets resource -- use the existing one and add the nested route
  </action>
  <verify>
    Run `ruby -c api/app/controllers/api/v1/price_snapshots_controller.rb` -- syntax OK.
    Run `bin/rails routes | grep price_snapshots` -- should show price_snapshots routes.
    Run `bin/rails runner "puts Api::V1::PriceSnapshotsController.new.respond_to?(:index)"` -- should print true.
  </verify>
  <done>PriceSnapshotsController returning OHLCV time series for a given asset within a date range. Both flat and nested routes available. Returns all data points in range (no pagination needed for daily candle data).</done>
</task>

</tasks>

<verification>
- All three controller files pass syntax check
- `bin/rails routes` shows routes for calls, assets, and price_snapshots
- Routes support both flat query params and nested resource patterns
- CallsController includes proper eager loading (includes :asset, :influencer, :content)
- PriceSnapshotsController returns 400 for missing asset_id
</verification>

<success_criteria>
- GET /api/v1/calls returns paginated calls with asset, influencer, and content data
- GET /api/v1/calls?influencer_id=X filters calls by influencer
- GET /api/v1/calls?asset_id=X filters calls by asset
- GET /api/v1/assets returns all assets (or only those with calls if with_calls=true)
- GET /api/v1/assets/:id returns asset detail with call stats
- GET /api/v1/price_snapshots?asset_id=X returns OHLCV time series for the asset
- All endpoints follow existing patterns (manual pagination, JSON serialization in controller)
</success_criteria>

<output>
After completion, create `.planning/phases/03-call-extraction-price-data/03-04-SUMMARY.md`
</output>

---
phase: 01-foundation-authentication
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - api/Dockerfile
  - api/config/database.yml
  - api/config/environments/production.rb
  - api/bin/docker-entrypoint
  - frontend/next.config.ts
  - .github/workflows/deploy.yml
autonomous: false

user_setup:
  - service: railway
    why: "Deployment platform for Rails API, Next.js frontend, PostgreSQL, and Redis"
    env_vars:
      - name: RAILS_MASTER_KEY
        source: "api/config/master.key (generated during rails new)"
      - name: SESSION_SECRET
        source: "Generate with: openssl rand -base64 32"
      - name: ADMIN_EMAIL
        source: "Your admin email address"
      - name: ADMIN_PASSWORD
        source: "Your admin password (change after first login)"
    dashboard_config:
      - task: "Create new project"
        location: "Railway Dashboard -> New Project"
      - task: "Add PostgreSQL service"
        location: "Project -> New -> Database -> PostgreSQL"
      - task: "Add Redis service"
        location: "Project -> New -> Database -> Redis"
      - task: "Deploy Rails API from GitHub"
        location: "Project -> New -> GitHub Repo -> Select repo, set root to /api"
      - task: "Deploy Next.js frontend from GitHub"
        location: "Project -> New -> GitHub Repo -> Select repo, set root to /frontend"
      - task: "Configure environment variables"
        location: "Each service -> Variables tab"
      - task: "Set up custom domains (optional)"
        location: "Each service -> Settings -> Domains"

must_haves:
  truths:
    - "Rails API is accessible at production URL"
    - "Next.js frontend is accessible at production URL"
    - "Health check endpoint returns 200"
    - "Admin can login on production"
    - "Session persists after browser refresh on production"
    - "CORS allows frontend to call API"
  artifacts:
    - path: "api/Dockerfile"
      provides: "Production Docker image for Rails"
      contains: "ENTRYPOINT"
    - path: "api/bin/docker-entrypoint"
      provides: "Startup script with migrations"
      contains: "db:migrate"
  key_links:
    - from: "frontend production"
      to: "api production /api/v1/*"
      via: "API_URL environment variable"
      pattern: "API_URL"
    - from: "api production"
      to: "PostgreSQL"
      via: "DATABASE_URL"
      pattern: "DATABASE_URL"
---

<objective>
Deploy Rails API and Next.js frontend to Railway

Purpose: Make the application accessible on the internet with production infrastructure (PostgreSQL, Redis). Verify all auth flows work in production environment.

Output:
- Rails API deployed and accessible via Railway URL
- Next.js frontend deployed and accessible via Railway URL
- PostgreSQL database provisioned and connected
- Redis provisioned (ready for background jobs in Phase 2)
- Production environment variables configured
- Health check working
</objective>

<execution_context>
@/Users/superuser/.claude/get-shit-done/workflows/execute-plan.md
@/Users/superuser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-authentication/01-RESEARCH.md
@.planning/phases/01-foundation-authentication/01-01-SUMMARY.md
@.planning/phases/01-foundation-authentication/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prepare Rails API for production deployment</name>
  <files>
    api/Dockerfile
    api/bin/docker-entrypoint
    api/config/database.yml
    api/config/environments/production.rb
    api/config/initializers/cors.rb
  </files>
  <action>
    1. Create Dockerfile for Rails (api/Dockerfile):
       ```dockerfile
       # syntax=docker/dockerfile:1
       ARG RUBY_VERSION=3.3.0
       FROM ruby:$RUBY_VERSION-slim AS base

       WORKDIR /rails

       ENV RAILS_ENV="production" \
           BUNDLE_DEPLOYMENT="1" \
           BUNDLE_PATH="/usr/local/bundle" \
           BUNDLE_WITHOUT="development:test"

       FROM base AS build

       RUN apt-get update -qq && \
           apt-get install --no-install-recommends -y \
           build-essential \
           git \
           libpq-dev \
           pkg-config && \
           rm -rf /var/lib/apt/lists /var/cache/apt/archives

       COPY Gemfile Gemfile.lock ./
       RUN bundle install && \
           rm -rf ~/.bundle/ "${BUNDLE_PATH}"/ruby/*/cache "${BUNDLE_PATH}"/ruby/*/bundler/gems/*/.git

       COPY . .

       RUN bundle exec bootsnap precompile app/ lib/

       FROM base

       RUN apt-get update -qq && \
           apt-get install --no-install-recommends -y \
           curl \
           libpq-dev && \
           rm -rf /var/lib/apt/lists /var/cache/apt/archives

       COPY --from=build /usr/local/bundle /usr/local/bundle
       COPY --from=build /rails /rails

       RUN useradd rails --create-home --shell /bin/bash && \
           chown -R rails:rails db log storage tmp
       USER rails:rails

       COPY --chmod=755 bin/docker-entrypoint /rails/bin/

       ENTRYPOINT ["/rails/bin/docker-entrypoint"]

       EXPOSE 3000
       CMD ["./bin/rails", "server", "-b", "0.0.0.0"]
       ```

    2. Create docker-entrypoint script (api/bin/docker-entrypoint):
       ```bash
       #!/bin/bash
       set -e

       # Run database migrations
       if [ "${SKIP_MIGRATIONS}" != "true" ]; then
         echo "Running database migrations..."
         ./bin/rails db:migrate
       fi

       # Seed database if needed (only run once)
       if [ "${RUN_SEED}" == "true" ]; then
         echo "Seeding database..."
         ./bin/rails db:seed
       fi

       exec "$@"
       ```
       Make executable: `chmod +x api/bin/docker-entrypoint`

    3. Update database.yml for production (api/config/database.yml):
       ```yaml
       default: &default
         adapter: postgresql
         encoding: unicode
         pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>

       development:
         <<: *default
         database: influenza_development

       test:
         <<: *default
         database: influenza_test

       production:
         <<: *default
         url: <%= ENV["DATABASE_URL"] %>
       ```

    4. Update production.rb for Railway (api/config/environments/production.rb):
       Ensure these settings:
       ```ruby
       # Force SSL in production
       config.force_ssl = true
       config.assume_ssl = true

       # Allow Railway health checks
       config.hosts << ENV["RAILWAY_PRIVATE_DOMAIN"] if ENV["RAILWAY_PRIVATE_DOMAIN"]
       config.hosts << ENV["RAILWAY_PUBLIC_DOMAIN"] if ENV["RAILWAY_PUBLIC_DOMAIN"]
       config.hosts << ".railway.app"

       # Logging
       config.log_level = :info
       config.log_tags = [:request_id]

       # Action Mailer (configure for production email service later)
       config.action_mailer.raise_delivery_errors = false
       config.action_mailer.default_url_options = {
         host: ENV.fetch("APP_HOST", "localhost"),
         protocol: "https"
       }
       ```

    5. Update CORS for production (api/config/initializers/cors.rb):
       ```ruby
       Rails.application.config.middleware.insert_before 0, Rack::Cors do
         allow do
           origins ENV["FRONTEND_URL"] || "http://localhost:3001"

           resource "/api/*",
             headers: :any,
             methods: [:get, :post, :put, :patch, :delete, :options, :head],
             credentials: true,
             expose: ["Authorization"]
         end
       end
       ```

    6. Create .dockerignore (api/.dockerignore):
       ```
       .git
       .gitignore
       log/*
       tmp/*
       storage/*
       .env*
       config/master.key
       config/credentials/*.key
       node_modules
       ```

    7. Add health check to routes if not already present (api/config/routes.rb):
       Verify: `get "health", to: proc { [200, {}, ["OK"]] }`
  </action>
  <verify>
    ```bash
    cd api
    docker build -t influenza-api . 2>&1 | tail -10
    cat bin/docker-entrypoint
    cat config/database.yml | grep -A 3 "production:"
    ```
    Docker build succeeds. Entrypoint exists and is executable. Production database config uses DATABASE_URL.
  </verify>
  <done>
    - Dockerfile created with multi-stage build for Rails
    - Docker entrypoint runs migrations on startup
    - database.yml uses DATABASE_URL for production
    - production.rb configured for Railway (hosts, SSL, logging)
    - CORS allows FRONTEND_URL in production
    - .dockerignore excludes sensitive files
    - Health check endpoint available
  </done>
</task>

<task type="auto">
  <name>Task 2: Prepare Next.js for production deployment</name>
  <files>
    frontend/next.config.ts
    frontend/.env.example
  </files>
  <action>
    1. Update next.config.ts for production (frontend/next.config.ts):
       ```typescript
       import type { NextConfig } from 'next'

       const nextConfig: NextConfig = {
         output: 'standalone',
         // Enable if using images from external domains later
         // images: {
         //   remotePatterns: [
         //     {
         //       protocol: 'https',
         //       hostname: '*.railway.app',
         //     },
         //   ],
         // },
       }

       export default nextConfig
       ```

    2. Create .env.example for documentation (frontend/.env.example):
       ```
       # Rails API URL (set by Railway referencing API service)
       API_URL=https://your-api.railway.app

       # Session encryption secret (generate with: openssl rand -base64 32)
       SESSION_SECRET=your-session-secret-at-least-32-chars-long

       # Public app name (visible to browser)
       NEXT_PUBLIC_APP_NAME=Influenza
       ```

    3. Add .env.local to .gitignore if not present (frontend/.gitignore):
       Ensure `.env.local` and `.env*.local` are in gitignore.

    4. Verify package.json has correct scripts (frontend/package.json):
       ```json
       {
         "scripts": {
           "dev": "next dev --port 3001",
           "build": "next build",
           "start": "next start",
           "lint": "next lint"
         }
       }
       ```
       Note: Railway will auto-detect Next.js and run build + start.
  </action>
  <verify>
    ```bash
    cd frontend
    cat next.config.ts
    cat .env.example
    npm run build
    ```
    Config has standalone output. Example env file exists. Build succeeds.
  </verify>
  <done>
    - next.config.ts configured with standalone output for Docker/Railway
    - .env.example documents required environment variables
    - Build succeeds with production configuration
    - Ready for Railway auto-detection and deployment
  </done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <action>Deploy to Railway</action>
  <instructions>
    Claude has prepared the Rails API and Next.js frontend for deployment. Now you need to:

    **1. Create Railway Project**
    - Go to https://railway.app/dashboard
    - Click "New Project" -> "Empty Project"
    - Name it "influenza" or similar

    **2. Add PostgreSQL Database**
    - In your project, click "New" -> "Database" -> "PostgreSQL"
    - Railway auto-provisions and creates DATABASE_URL

    **3. Add Redis (for future background jobs)**
    - Click "New" -> "Database" -> "Redis"
    - Railway auto-provisions and creates REDIS_URL

    **4. Deploy Rails API**
    - Click "New" -> "GitHub Repo"
    - Select your repository
    - Set "Root Directory" to `/api`
    - Railway detects Dockerfile and builds automatically

    **5. Configure Rails API Environment Variables**
    - Go to API service -> "Variables" tab
    - Add these variables:
      - `RAILS_MASTER_KEY`: Copy from `api/config/master.key`
      - `FRONTEND_URL`: Will be set after frontend deploys (leave empty for now)
      - `ADMIN_EMAIL`: Your admin email (e.g., admin@yourdomain.com)
      - `ADMIN_PASSWORD`: Initial admin password (change after first login!)
      - `RUN_SEED`: Set to `true` for first deploy only (creates admin user)
    - Railway auto-injects: DATABASE_URL, REDIS_URL, RAILWAY_* variables

    **6. Deploy Next.js Frontend**
    - Click "New" -> "GitHub Repo"
    - Select your repository (same repo)
    - Set "Root Directory" to `/frontend`
    - Railway auto-detects Next.js

    **7. Configure Frontend Environment Variables**
    - Go to Frontend service -> "Variables" tab
    - Add these variables:
      - `API_URL`: Click "Add Reference" -> Select API service -> Use private domain with https:// prefix
        Example: `https://${{api.RAILWAY_PRIVATE_DOMAIN}}`
      - `SESSION_SECRET`: Generate with `openssl rand -base64 32`

    **8. Generate Public Domains**
    - Go to each service -> "Settings" -> "Domains"
    - Click "Generate Domain" for both services
    - Note the frontend URL (e.g., influenza-frontend.railway.app)

    **9. Update FRONTEND_URL on API**
    - Go back to API service -> "Variables"
    - Set `FRONTEND_URL` to your frontend's Railway URL (e.g., https://influenza-frontend.railway.app)
    - This fixes CORS for production

    **10. Verify Deployment**
    - Visit API health check: https://your-api.railway.app/health (should return "OK")
    - Visit frontend: https://your-frontend.railway.app (should show login page)
    - Try logging in with admin credentials

    **11. Remove RUN_SEED**
    - After first successful deployment, remove `RUN_SEED=true` from API variables
    - This prevents re-seeding on future deploys
  </instructions>
  <resume-signal>
    When deployment is complete, provide:
    1. API URL (e.g., https://influenza-api.railway.app)
    2. Frontend URL (e.g., https://influenza-frontend.railway.app)
    3. Confirmation that admin login works

    Type "deployed" followed by the URLs to continue.
  </resume-signal>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Full authentication system deployed to production:
    - Rails API with PostgreSQL and Redis on Railway
    - Next.js frontend on Railway
    - Admin account created
    - All auth flows functional
  </what-built>
  <how-to-verify>
    Test the complete authentication flow on production:

    1. **Health Check**
       - Visit: [API_URL]/health
       - Expected: Page shows "OK"

    2. **Login Flow**
       - Visit: [FRONTEND_URL]/login
       - Enter admin email and password
       - Expected: Redirects to dashboard, shows email

    3. **Session Persistence**
       - After login, refresh the page (Ctrl/Cmd + R)
       - Expected: Still logged in, dashboard visible

    4. **Logout Flow**
       - Click "Sign out" on dashboard
       - Expected: Redirects to login page

    5. **Route Protection**
       - Try visiting [FRONTEND_URL]/ while logged out
       - Expected: Redirects to /login

    6. **Invitation Flow (optional - requires mailer config)**
       - If email is configured, test invitation:
         - Login as admin
         - Create invitation via API (curl or future admin UI)
         - Check invited email for signup link
         - Complete signup

    7. **Password Reset (optional - requires mailer config)**
       - Click "Forgot your password?" on login
       - Enter email, submit
       - If email configured, check for reset link
  </how-to-verify>
  <resume-signal>
    Type "verified" if all flows work correctly.

    If issues, describe what's not working:
    - "login fails with [error]"
    - "session not persisting"
    - "CORS error on API call"
    - etc.
  </resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:

1. Rails API accessible at Railway URL
2. Health check returns 200 OK
3. Next.js frontend accessible at Railway URL
4. Login page renders
5. Admin can login
6. Session persists across refresh
7. Logout works
8. Route protection works
</verification>

<success_criteria>
- Rails API deployed to Railway with PostgreSQL
- Redis provisioned (ready for Phase 2)
- Next.js frontend deployed to Railway
- Both services have public URLs
- CORS configured for frontend-to-API communication
- Admin user exists and can login
- Full auth flow works in production
- Session persists across browser refresh
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-03-SUMMARY.md`
</output>
